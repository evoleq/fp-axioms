package org.evoleq.axioms.processor

import com.google.devtools.ksp.getVisibility
import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.ksp.toTypeName
import com.squareup.kotlinpoet.ksp.writeTo

class LensProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) : SymbolProcessor {

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val symbols = resolver.getSymbolsWithAnnotation("org.evoleq.axioms.definition.Lensify")
        val ret = symbols.filter { !it.validate() }.toList()
        
        symbols.filterIsInstance<KSClassDeclaration>()
            .filter { it.validate() }
            .forEach { it.accept(LensifyVisitor(), Unit) }
            
        return ret
    }

    inner class LensifyVisitor : KSVisitorVoid() {
        override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: Unit) {
            val packageName = classDeclaration.packageName.asString()
            val className = classDeclaration.simpleName.asString()
            val classType = classDeclaration.asType(emptyList()).toTypeName()
            val fileName = with(classDeclaration.containingFile?.fileName?.substringBeforeLast(".kt")) {
                if(this == null) "${className}Lenses" else "$this.lenses"
            }
            // WICHTIG: Hier mappen wir die Sichtbarkeit manuell.
            // Wenn die Klasse PUBLIC ist, geben wir eine leere Liste zurück.
            // Dadurch wird im generierten Code KEIN Sichtbarkeits-Keywort (wie public) erzeugt.
            val visibilityModifiers = when (classDeclaration.getVisibility()) {
                Visibility.INTERNAL -> listOf(KModifier.INTERNAL)
                Visibility.PRIVATE -> listOf(KModifier.PRIVATE)
                Visibility.PROTECTED -> listOf(KModifier.PROTECTED)
                else -> emptyList() // Hier landet 'PUBLIC' -> führt zu keinem Keyword im Output
            }

            val fileSpecBuilder = FileSpec.builder(packageName, fileName)

            classDeclaration.getAllProperties().forEach { prop ->
                val propName = prop.simpleName.asString()
                val propType = prop.type.toTypeName()
                
                val isReadOnly = prop.annotations.any { it.shortName.asString() == "ReadOnly" }
                val isReadWrite = prop.annotations.any { it.shortName.asString() == "ReadWrite" }

                if (isReadOnly) {
                    fileSpecBuilder.addProperty(generateReadOnlyLens(className, classType, propName, propType, visibilityModifiers))
                } else if (isReadWrite) {
                    fileSpecBuilder.addProperty(generateReadWriteLens(className, classType, propName, propType, visibilityModifiers))
                    fileSpecBuilder.addFunction(generateSetterExtension(className, classType, propName, propType, visibilityModifiers))
                }
            }

            fileSpecBuilder.build().writeTo(codeGenerator, Dependencies(false, classDeclaration.containingFile!!))
        }

        private fun generateReadOnlyLens(className: String, classType: TypeName, propName: String, propType: TypeName, modifiers: List<KModifier>): PropertySpec {
            return PropertySpec.builder(propName, ClassName("org.evoleq.optics.lens", "Lens").parameterizedBy(classType, propType))
                .addModifiers(modifiers) // Wenn Liste leer ist, wird nichts (also kein public) eingefügt
                .addAnnotation(ClassName("org.evoleq.axioms.definition", "ReadOnly"))
                .delegate(
                    CodeBlock.builder()
                        .beginControlFlow("lazy")
                        .add("Lens(⇥\n")
                        .add("get = { whole -> whole.%L },\n", propName)
                        .add("set = { { it } }\n")
                        .unindent()
                        .add(")")
                        .endControlFlow()
                        .build()
                )
                .addKdoc("Autogenerated ReadOnly Lens.\nRead [%L.%L]", className, propName)
                .build()
        }

        private fun generateReadWriteLens(className: String, classType: TypeName, propName: String, propType: TypeName, modifiers: List<KModifier>): PropertySpec {
            return PropertySpec.builder(propName, ClassName("org.evoleq.optics.lens", "Lens").parameterizedBy(classType, propType))
                .addModifiers(modifiers)
                .addAnnotation(ClassName("org.evoleq.axioms.definition", "ReadWrite"))
                .delegate(
                    CodeBlock.builder()
                        .beginControlFlow("lazy")
                        .add("Lens(⇥\n")
                        .add("get = { whole -> whole.%L },\n", propName)
                        .add("set = { part -> { whole -> whole.copy(%L = part) } }\n", propName)
                        .unindent()
                        .add(")")
                        .endControlFlow()
                        .build()
                )
                .addKdoc("Autogenerated Lens.\nRead and manipulate [%L.%L]", className, propName)
                .build()
        }

        private fun generateSetterExtension(className: String, classType: TypeName, propName: String, propType: TypeName, modifiers: List<KModifier>): FunSpec {
            return FunSpec.builder(propName)
                .receiver(classType)
                .addModifiers(modifiers)
                .addAnnotation(ClassName("org.evoleq.axioms.definition", "ReadWrite"))
                .addParameter("set", LambdaTypeName.get(receiver = propType, returnType = propType))
                .returns(classType)
                .addStatement("return copy(%L = set(%L))", propName, propName)
                .addKdoc("Autogenerated Setter of a Pseudo Lens\nManipulate [%L.%L]", className, propName)
                .build()
        }
    }
}